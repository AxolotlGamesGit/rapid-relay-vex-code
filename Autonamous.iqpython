{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nChoochoo = Motor(Ports.PORT6, False)\nFlywheel = Motor(Ports.PORT4, False)\nTensioner = Motor(Ports.PORT3, False)\nIntakeDistance = Distance(Ports.PORT5)\nLeft = Motor(Ports.PORT2, False)\nRight = Motor(Ports.PORT1, True)\nBackDistance = Distance(Ports.PORT12)\n\n\n\n# generating and setting random seed\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    systemTime = brain.timer.system() * 100\n    urandom.seed(int(xaxis + yaxis + zaxis + systemTime)) \n    \n# Initialize random seed \ninitializeRandomSeed()\n\n#endregion VEXcode Generated Robot Configuration\n\nvexcode_brain_precision = 0\nvexcode_console_precision = 0\nLow = 5.5\nHigh = 6.5\nTension = High\nDirection = FORWARD\nBalls = 0\nGoals = 0\nBall_Distance_Goal = 300\nPast_Distance = Ball_Distance_Goal + 1\nReady_Percent = 100\n\ndef frame():\n    global Goals, Low, High, Tension, Direction, Balls, Ready_Percent, BallDistance, BallDistanceGoal, Past_Distance\n    Tensioner.set_velocity(abs(Tension-Tensioner.position(TURNS))*300, PERCENT)\n    Tensioner.spin_to_position(Tension, TURNS, wait=False)\n            \n    # 0 Balls means none in the cata, 1 means 1 in the cata and still picking up a\n    # second ball. 2 means 2 Balls, with 1 in the middle of the flywheel.\n    current_distance = IntakeDistance.object_distance(MM)\n\n    if (current_distance < Ball_Distance_Goal):\n        if (Balls == 0):\n            Balls = 1\n        elif (Balls == 1 and Past_Distance > Ball_Distance_Goal):\n            Balls = 1.1\n        elif (Balls < 2):\n            Balls += 0.1\n    elif (Past_Distance < Ball_Distance_Goal and Direction == REVERSE):\n        Balls = math.floor(Balls - 0.1)\n\n    Past_Distance = IntakeDistance.object_distance(MM)\n\n    # Ball juggling\n    if (Balls == 2):\n        Flywheel.set_velocity((Left.velocity(RPM) + Right.velocity(RPM)) / 2, RPM)\n\n    # Intake\n    Flywheel.spin(Direction)\n    \n    # Used in shoot function\n    Ready_Percent = Choochoo.position(TURNS) >= (Goals * 1.5) - 0.1\n        \n    wait(20, MSEC)\n\n# Sets the speeds of the wheels. This can be edited to correct drift.\ndef speed(left, right):\n    Left.set_velocity(left,PERCENT)\n    Right.set_velocity(right,PERCENT)\n    Left.spin(FORWARD)\n    Right.spin(FORWARD)\n\n# Drives until the back is a certain distance away from the wall.\n# This uses a simple P controller right now, which might not be accurate but it is consistant.\ndef drive_to_distance(driveDistance, sLowThreshold=100):\n    while BackDistance.object_distance(MM) < driveDistance:\n        if (brain.timer.time(SECONDS) < 59):\n            drive_speed = (100/sLowThreshold) * (driveDistance - BackDistance.object_distance(MM))\n            speed(drive_speed, drive_speed)\n            frame()\n        else:\n            speed(0,0)\n\n# Turns a specific amount in a specific direction. \n# This used a PD controller, but it isn't very accurate right now.\n# We won't add integrals, so I hope that we can tune the values well enough.\ndef turn(turn_distance, direction=\"Clockwise\", kp=0.6, kd=5, accuracy=5):\n    if (direction == \"Clockwise\"):\n        brain_inertial.set_heading(0, DEGREES)\n    if (direction == \"Counterclockwise\"):\n        brain_inertial.set_heading(180, DEGREES)\n\n    current_heading = brain_inertial.heading(DEGREES)\n    start_heading = current_heading\n    past_heading = current_heading\n    \n    while abs(current_heading - (turn_distance + start_heading) > accuracy):\n        if (brain.timer.time(SECONDS) < 59):\n            current_heading = brain_inertial.heading(DEGREES)\n            p = kp * (turn_distance + start_heading - current_heading)\n            d = kd * (current_heading - past_heading)\n\n            if (direction == \"Clockwise\"):\n                speed(p + d, -1 * (p + d))\n            else:\n                speed(-1 * (p + d), p + d)\n            \n            past_heading = current_heading\n            frame()\n        else:\n            speed(0,0)\n\n# Backs up to the wall. It keeps going at full speed for 100 msecs to make sure that it flattens out.\ndef back_up():\n    while BackDistance.object_distance(MM) > 10:\n        speed(-100, -100)\n        frame()\n    wait(100, MSEC)\n    speed(0,0)\n\n# Shoots, then waits until the choochoo is a specified percent away from finishing.\n# This uses the shoot_percent variable found at the end of frame because it updates constantly.\n# If you call it early, it should wait until the catapult is ready. This is because it uses\n# the spin_to_position function and calculates where the catapult should be after one more goal. This still needs to be tested.\ndef shoot(waitPercent):\n    global Ready_Percent, Goals\n    \n    if brain.timer.time(SECONDS) < 56:\n        Choochoo.spin_to_position((Goals + 1) * 1.5, TURNS, wait=False)\n        Goals += 1\n        while (Ready_Percent < waitPercent):\n            frame()\n    else:\n        if brain.timer.time(SECONDS) < 58.5:\n            Goals += 1\n        while brain.timer.time(SECONDS) < 59:\n            Choochoo.set_velocity(100,PERCENT)\n        Choochoo.set_velocity(0,PERCENT)\n\n# Called at the start of the program, so the waitng code is in here.\ndef start():\n    global Tension, High, Low, Ready_Percent\n\n    brain_inertial.calibrate()\n    while (brain_inertial.is_calibrating()):\n        brain.screen.clear_screen()\n        brain.screen.print_at(20, 20, \"Calibrating inertial\")\n\n    while (not brain.buttonRight.pressing()):\n        pass\n    \n    brain.timer.clear()\n    brain_inertial.set_heading(180,DEGREES)\n    \n    # Drives away from the start and turns left\n    drive_to_distance(300)\n    turn(90, \"Counterclockwise\")\n\n    drive_to_distance(800) # Picks up the ball in starting zone 1\n    turn(180) # Implied clockwise\n    \n    # Shoots into both switches\n    Tension = High\n    back_up()\n    shoot(30) # 30 percent should make sure that the ball has been shot, while giving time for the tension to change.\n    Tension = Low\n    shoot(30)\n\n    # Drives to the other side\n    drive_to_distance(500)\n    turn(90, \"Counterclockwise\")\n    drive_to_distance(500)\n    turn(90, \"Clockwise\")\n\n    # Shoots both switches again\n    Tension = High\n    back_up()\n    shoot(30)\n    Tension = Low\n    shoot(30)\n\n    # Goes back and forth shooting into the low goal from a distance\n    while (brain.timer.time(SECONDS) < 60):\n        Tension = 6\n\n        drive_to_distance(500)\n        drive_to_distance(200)\n        shoot(30)\n        shoot(100)\n\n# add 15ms delay to make sure events are registered correctly.\nwait(15, MSEC)\n\nstart()\n","textLanguage":"python","robotConfig":[{"port":[6],"name":"Choochoo","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[4],"name":"Flywheel","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[3],"name":"Tensioner","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[5],"name":"IntakeDistance","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[2],"name":"Left","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"}},{"port":[1],"name":"Right","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"}},{"port":[12],"name":"BackDistance","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{}}],"slot":1,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"target":"Physical"}
